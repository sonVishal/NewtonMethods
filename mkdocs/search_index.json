{
    "docs": [
        {
            "location": "/",
            "text": "Numerical solution of nonlinear (NL) equations (EQ) especially designed for numerically sensitive problems.\n\n\nBased on the Fortran solvers \nNewtonLib\n.\n\n\n#\n\n\nNewtonMethods\n \u2014 \nModule\n.\n\n\nReferences:\n\n\n\n\nP. Deuflhard:  Newton Methods for Nonlinear Problems. -  Affine Invariance and Adaptive Algorithms.  Series Computational Mathematics 35, Springer (2004)\n\n\nU. Nowak, L. Weimann:  A Family of Newton Codes for Systems of Highly Nonlinear  Equations - Algorithm, Implementation, Application.  ZIB, Technical Report TR 90-10 (December 1990)\n\n\n\n\nCurrently the following two solvers are implemented:\n\n\n\n\nNLEQ1: Damped Newton-algorithm for systems of highly nonlinear   equations - damping strategy due to Ref. (1).\n\n\nNLEQ2: Damped Newton-algorithm with rank strategy for systems of   highly nonlinear equations - damping strategy due to Ref.(1).\n\n\n\n\nsource\n\n\n\n\nTutorials\n\n\n\n\nIndex of functions\n\n\n\n\nNewtonMethods\n\n\nNewtonMethods.AbstractOptionsNLEQ\n\n\nNewtonMethods.OptionsNLEQ\n\n\nNewtonMethods.checkOptions\n\n\nNewtonMethods.clearWorkspace\n\n\nNewtonMethods.copyOptions!\n\n\nNewtonMethods.deccon\n\n\nNewtonMethods.dgbfa\n\n\nNewtonMethods.dgbsl\n\n\nNewtonMethods.getMachineConstants\n\n\nNewtonMethods.getOption\n\n\nNewtonMethods.getOption!\n\n\nNewtonMethods.initOption!\n\n\nNewtonMethods.initOptions!\n\n\nNewtonMethods.initializeOptions\n\n\nNewtonMethods.n1int\n\n\nNewtonMethods.n2int\n\n\nNewtonMethods.n2prjn\n\n\nNewtonMethods.nFact\n\n\nNewtonMethods.nJacFD\n\n\nNewtonMethods.nJacFDb\n\n\nNewtonMethods.nJcf\n\n\nNewtonMethods.nJcfb\n\n\nNewtonMethods.nLvls\n\n\nNewtonMethods.nPrv1\n\n\nNewtonMethods.nPrv2\n\n\nNewtonMethods.nScal\n\n\nNewtonMethods.nScrb\n\n\nNewtonMethods.nScrf\n\n\nNewtonMethods.nSolv\n\n\nNewtonMethods.nSout\n\n\nNewtonMethods.nleq1\n\n\nNewtonMethods.nleq2\n\n\nNewtonMethods.printInitialization\n\n\nNewtonMethods.printStats\n\n\nNewtonMethods.setOption!\n\n\nNewtonMethods.setOptions!\n\n\nNewtonMethods.solcon\n\n\nNewtonMethods.wnorm",
            "title": "Introduction"
        },
        {
            "location": "/#numerical-solution-of-nonlinear-nl-equations-eq-especially-designed-for-numerically-sensitive-problems",
            "text": "Based on the Fortran solvers  NewtonLib .  #  NewtonMethods  \u2014  Module .  References:   P. Deuflhard:  Newton Methods for Nonlinear Problems. -  Affine Invariance and Adaptive Algorithms.  Series Computational Mathematics 35, Springer (2004)  U. Nowak, L. Weimann:  A Family of Newton Codes for Systems of Highly Nonlinear  Equations - Algorithm, Implementation, Application.  ZIB, Technical Report TR 90-10 (December 1990)   Currently the following two solvers are implemented:   NLEQ1: Damped Newton-algorithm for systems of highly nonlinear   equations - damping strategy due to Ref. (1).  NLEQ2: Damped Newton-algorithm with rank strategy for systems of   highly nonlinear equations - damping strategy due to Ref.(1).   source",
            "title": "Numerical solution of nonlinear (NL) equations (EQ) especially designed for numerically sensitive problems."
        },
        {
            "location": "/#tutorials",
            "text": "",
            "title": "Tutorials"
        },
        {
            "location": "/#index-of-functions",
            "text": "NewtonMethods  NewtonMethods.AbstractOptionsNLEQ  NewtonMethods.OptionsNLEQ  NewtonMethods.checkOptions  NewtonMethods.clearWorkspace  NewtonMethods.copyOptions!  NewtonMethods.deccon  NewtonMethods.dgbfa  NewtonMethods.dgbsl  NewtonMethods.getMachineConstants  NewtonMethods.getOption  NewtonMethods.getOption!  NewtonMethods.initOption!  NewtonMethods.initOptions!  NewtonMethods.initializeOptions  NewtonMethods.n1int  NewtonMethods.n2int  NewtonMethods.n2prjn  NewtonMethods.nFact  NewtonMethods.nJacFD  NewtonMethods.nJacFDb  NewtonMethods.nJcf  NewtonMethods.nJcfb  NewtonMethods.nLvls  NewtonMethods.nPrv1  NewtonMethods.nPrv2  NewtonMethods.nScal  NewtonMethods.nScrb  NewtonMethods.nScrf  NewtonMethods.nSolv  NewtonMethods.nSout  NewtonMethods.nleq1  NewtonMethods.nleq2  NewtonMethods.printInitialization  NewtonMethods.printStats  NewtonMethods.setOption!  NewtonMethods.setOptions!  NewtonMethods.solcon  NewtonMethods.wnorm",
            "title": "Index of functions"
        },
        {
            "location": "/tutorial/nleq1/",
            "text": "NLEQ1 example solution",
            "title": "NELQ1"
        },
        {
            "location": "/tutorial/nleq1/#nleq1-example-solution",
            "text": "",
            "title": "NLEQ1 example solution"
        },
        {
            "location": "/tutorial/nleq2/",
            "text": "NLEQ2 example solution",
            "title": "NELQ2"
        },
        {
            "location": "/tutorial/nleq2/#nleq2-example-solution",
            "text": "",
            "title": "NLEQ2 example solution"
        },
        {
            "location": "/functions/nleq1/",
            "text": "#\n\n\nNewtonMethods.dgbfa\n \u2014 \nFunction\n.\n\n\nSummary:\n\n\nfunction dgbfa{T}(abd::Array{T,2}, lda::Int64, n::Int64, ml::Int64, mu::Int64)\n\n\nThis function is similar to the function gbtrf! provided in Base.LinAlg.LAPACK. Julia documentation mentions the following:\n\n\nNote that the LAPACK API provided by Julia can and will change in the future.\n \nSince this API is not user-facing, there is no commitment to support/deprecate\n \nthis specific set of functions in future releases.\n\n\nDue to this reason dgbfa function has been written as per the one provided in the original version of these solvers at: \nNewtonLib\n based on LINPACK written for Matlab by Cleve Moler, University of New Mexico, Argonne National Lab.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nabd[lda,n]*\n\n\nContains the matrix in band storage. See the comments below.\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the matrix. lda >= 2*ml + mu + 1\n\n\n\n\n\n\nn\n\n\nOrder of the original matrix\n\n\n\n\n\n\nml\n\n\nNumber of diagonals below the main diagonal. 0 <= ml < n\n\n\n\n\n\n\nmu\n\n\nNumber of diagonals above the main diagonal. 0 <= mu < n\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nabd[lda,n]*\n\n\nAn upper triangular matrix in band storage and the multipliers which were used to obtain it. Factorization can be written as a = l*u where l is a product of permutation and unit lower triangular matrices and u is upper triangular.\n\n\n\n\n\n\nipvt\n\n\nVector containing the pivot indices\n\n\n\n\n\n\ninfo = 0\n\n\nNormal value\n\n\n\n\n\n\ninfo = k\n\n\nif u(k,k) = 0.0. This only indicates that dgbsl will divide by zero if called.\n\n\n\n\n\n\n\n\nBand storage\n\n\nIf a is a band matrix, the following program segment will set up input matrix abd\n\n\nml = (bandwidth below the diagonal)\nmu = (bandwidth above the diagonal)\nm = ml + mu + 1\nfor j = 1:n\n    i1 = max(1,j-mu)\n    i2 = min(n,j+ml)\n    for i = i1:i2\n        k = i - j + m\n        abd[k,j] = a[i,j]\n    end\nend\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.dgbsl\n \u2014 \nFunction\n.\n\n\nfunction dgbsl{T}(abd::Array{T,2}, lda::Int64, n::Int64, ml::Int64, mu::Int64,     ipvt::Vector{Int64}, b::Vector{T}, flag::Int64)\n\n\nSolves the double precision band system using the factors computed by dgbfa.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nabd[lda,n]\n\n\nMatrix output from dgbfa\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the matrix abd\n\n\n\n\n\n\nn\n\n\nOrder of the original matrix\n\n\n\n\n\n\nml\n\n\nNumber of diagonals below the main diagonal\n\n\n\n\n\n\nmu\n\n\nNumber of diagonals above the main diagonal\n\n\n\n\n\n\nipvt\n\n\nVector containing the pivot indices from dgbfa\n\n\n\n\n\n\nb\n\n\nRight hand side vector\n\n\n\n\n\n\ninfo = 0\n\n\nSolve a*x = b\n\n\n\n\n\n\ninfo != 0\n\n\nSolve trans(a)*x = b\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx\n\n\nSolution vector\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nleq1\n \u2014 \nFunction\n.\n\n\nfunction nleq1{T}(fcn, x::Vector{T}, xScal::Vector{T}, opt::OptionsNLEQ)\n\n\nDamped Newton-algorithm for systems of highly nonlinear equations - damping strategy due to Ref. (1).\n\n\n(The iteration is done by function N1INT currently. NLEQ1 itself does some house keeping and builds up workspace.)\n\n\nJacobian approximation by numerical differences, user supplied function JAC or forward mode automatic differentation.\n\n\nThe numerical solution of the arising linear equations is done by means of Julia builtin lu-factorization routine in the dense or sparse matrix case; or by the functions DGBFA and DGBSL, which have been converted from the equal named Fortran LINPACK subroutines into Julia code, in the band matrix case. For special purposes these routines may be substituted.\n\n\nThis is a driver routine for the core solver N1INT.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfcn\n\n\nFunction for which zero is to be found. Should be in the form of fcn(y,x) with y = f(x).\n\n\n\n\n\n\nx[1:n]\n\n\nInitial estimate of the solution.\n\n\n\n\n\n\nxScal[1:n]\n\n\nUser scaling (lower threshold) of the iteration vector x\n\n\n\n\n\n\nopt\n\n\nOptions for solving the nonlinear system. Valid options are listed below.\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx0[1:n]\n\n\nSolution values (or final values if exit before solution is reached).\n\n\n\n\n\n\nstats\n\n\nA dictionary variable of additional output values. The fields are discussed below.\n\n\n\n\n\n\nretCode\n\n\nAn integer value signifying the exit code. The meaning of the exit codes are discussed below.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.n1int\n \u2014 \nFunction\n.\n\n\nfunction n1int{T}(n::Int64, fcn, x::Vector{T}, xScal::Vector{T},     rTol::T, nItmax::Int64, nonLin::Int64, opt::OptionsNLEQ,     m1::Int64, m2::Int64, nBroy::Int64, fc::T, fcMin::T,     sigma::T, sigma2::T, mStor::Int64, mPrWarn::Int64, mPrMon::Int64,     mPrSol::Int64, printIOwarn, printIOmon, printIOsol, qBDamp::Bool)\n\n\nCore routine for NLEQ1.\n\n\nDamped Newton-algorithm for systems of highly nonlinear equations especially designed for numerically sensitive problems.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of vector components\n\n\n\n\n\n\nfcn\n\n\nFunction for which zero is to be found. Should be in the form of fcn(y,x) with y = f(x).\n\n\n\n\n\n\nx[1:n]*\n\n\nInitial estimate of the solution.\n\n\n\n\n\n\nxScal[1:n]\n\n\nUser scaling (lower threshold) of the iteration vector x\n\n\n\n\n\n\nrTol\n\n\nRequired relative precision of solution components\n\n\n\n\n\n\nnItmax\n\n\nMaximum number of allowed iterations\n\n\n\n\n\n\nnonLin\n\n\nProblem type specification. See OPT_NONLIN field in solver options\n\n\n\n\n\n\nopt\n\n\nOptions for solving the nonlinear system. Valid options are listed below.\n\n\n\n\n\n\nm1\n\n\nLeading dimension of Jacobian array a\n\n\n\n\n\n\nm2 = n\n\n\nFor full mode\n\n\n\n\n\n\n= ml+mu+1\n\n\nFor band mode\n\n\n\n\n\n\nnBroy\n\n\nMaximum possible consecutive iterative Broyden steps.\n\n\n\n\n\n\nfc\n\n\nCurrent Newton iteration damping factor.\n\n\n\n\n\n\nfcMin\n\n\nMinimum permitted damping factor. fc < fcMin results in either of the following\n\n\n\n\n\n\n\n\na. Recomputation of the Jacobian using difference approximation\n\n\n\n\n\n\n\n\nb. Fail exit\n\n\n\n\n\n\nsigma\n\n\nDecision parameter for rank1-updates\n\n\n\n\n\n\nsigma2\n\n\nDecision parameter for damping factor increasing to corrector\n\n\n\n\n\n\nmStor\n\n\nDecision parameter for matrix storage. See option OPT_MSTOR in solver options.\n\n\n\n\n\n\nmPrWarn\n\n\nDecision parameter for printing warning messages\n\n\n\n\n\n\nmPrMon\n\n\nDecision parameter for printing iteration monitor\n\n\n\n\n\n\nmPrSol\n\n\nDecision parameter for printing solution\n\n\n\n\n\n\nprintIOwarn\n\n\nIO handle for printing warning\n\n\n\n\n\n\nprintIOmon\n\n\nIO handle for printing iteration monitor\n\n\n\n\n\n\nprintIOsol\n\n\nIO handle for printing solution\n\n\n\n\n\n\nqBDamp\n\n\nDecision parameter for matrix storage. See option OPT_MSTOR in solver options.\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx[1:n]*\n\n\nSolution values (or final values if exit before solution is reached).\n\n\n\n\n\n\nretCode\n\n\nAn integer value signifying the exit code. The meaning of the exit codes are discussed below.\n\n\n\n\n\n\n\n\nsource",
            "title": "NLEQ1"
        },
        {
            "location": "/functions/nleq2/",
            "text": "#\n\n\nNewtonMethods.deccon\n \u2014 \nFunction\n.\n\n\nfunction deccon{T}(a::Array{T,2}, nRow::Int64, nCol::Int64, mCon::Int64,     m::Int64, n::Int64, iRankC::Int64, iRank::Int64, cond::T,     d::Vector{T}, pivot::Vector{Int64}, kRed::Int64, ah::Array{T,2})\n\n\nConstrained QR-decomposition of (m,n)-system  with computation of pseudoinverse in case of rank-defeciency. First mcon rows belong to equality constraints.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na[nRow,nCol]*\n\n\nArray holding the (m,n) matrix to be decomposed\n\n\n\n\n\n\nnRow\n\n\nDeclared number of rows of array a\n\n\n\n\n\n\nnCol\n\n\nDeclared number of columns of array a and rows and columns of ah\n\n\n\n\n\n\nmCon\n\n\nNumber of equality constraints. mCon <= n. Internally reduced if equality constraints are linearly dependent\n\n\n\n\n\n\nm\n\n\nCurrent number of rows of array a\n\n\n\n\n\n\nn\n\n\nCurrent number of columns of array a\n\n\n\n\n\n\niRankC*\n\n\nPrescribed maximum pseudo-rank of constrained part of a. iRankC <= mCon\n\n\n\n\n\n\niRank*\n\n\nPrescribed maximum pseudo-rank of matrix a. iRank <= n\n\n\n\n\n\n\ncond*\n\n\nPermitted upper bound for the subcondition of least squares part of a\n\n\n\n\n\n\nkRed >= 0\n\n\nHouseholder triangularization. Build up pseudo-inverse if iRank < n\n\n\n\n\n\n\nkRed < 0\n\n\nReduction of pseudo-rank of matrix a, skipping Householder triangularization, build-up new pseudo-inverse\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na[nRow,nCol]*\n\n\nUpper triangular part consisting of transformed matrix and lower triangular part consisting of Householder transformations\n\n\n\n\n\n\niRankC*\n\n\nNew pseudo-rank of constrained part of a such that abs(d[1]/d[iRankC]) < 1/epMach\n\n\n\n\n\n\niRank*\n\n\nNew pseudo-rank of matrix a such that abs(d[iRankC+1]/d[iRank]) < cond\n\n\n\n\n\n\ncond*\n\n\nThe subcondition number belonging to the least squares part of A. In case of rank reduction: subcondition number which led to rank reduction\n\n\n\n\n\n\nd\n\n\nDiagonal elements of the upper triangular matrix\n\n\n\n\n\n\npivot\n\n\nIndex vector storing permutation of columns due to pivoting\n\n\n\n\n\n\nah[nCol,nCol]\n\n\nIn case of rank-defect used to compute the psuedo-inverse\n\n\n\n\n\n\niFail = 0\n\n\ndeccon computation was successful\n\n\n\n\n\n\niFail = -2\n\n\nNumerically negative diagonal element encountered during computation of pseudo-inverse due to extremely bad conditioned matrix a. deccon is unable to continue rank-reduction\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.solcon\n \u2014 \nFunction\n.\n\n\nfunction solcon{T}(a::Array{T,2}, nRow::Int64, nCol::Int64, mCon::Int64, m::Int64,     n::Int64, x::Vector{T}, b::Vector{T}, iRankC::Int64, iRank::Int64,     d::Vector{T}, pivot::Vector{Int64}, kRed::Int64, ah::Array{T,2})\n\n\nBest constrained linear least squares solution of (m,n)-system. First mcon rows comprise mcon equality constraints. To be used in connection with subroutine deccon.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na[m,n], nRow, nCol, m, n, mCon, iRankC, iRank, d[n], pivot[n], ah[n,n], kRed\n\n\nRefer to input and output parameters of deccon\n\n\n\n\n\n\nb[m]*\n\n\nRight hand side of the linear system if kRed >= 0. Right hand side of the upper linear system if kRed < 0\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx[n]\n\n\nBest LSQ-solution of linear system\n\n\n\n\n\n\nb[m]*\n\n\nRight-hand side of upper triangular system (transformed right-hand side of linear system)\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.n2prjn\n \u2014 \nFunction\n.\n\n\nfunction n2prjn{T}(n::Int64, iRank::Int64, u::Vector{T}, d::Vector{T},     qe::Array{T,2}, p::Vector{Int64}, v::Vector{T})\n\n\nProvides the projection to the appropriate subspace in case     of rank - reduction. To be used in connection with DECCON/SOLCON.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of parameters to be estimated\n\n\n\n\n\n\niRank\n\n\nPseudo rank of decomposed Jacobian matrix\n\n\n\n\n\n\nu[n]\n\n\nScaled Newton correction\n\n\n\n\n\n\nd[n]\n\n\nDiagonal elements of upper triangular matrix\n\n\n\n\n\n\nqe[n]\n\n\nPart of pseudoinverse Jacobian matrix\n\n\n\n\n\n\np[n]\n\n\nPivot vector resulting from matrix decomposition\n\n\n\n\n\n\nv[n]\n\n\nTemporary work array\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndel\n\n\nDefect\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nleq2\n \u2014 \nFunction\n.\n\n\nfunction nleq2{T}(fcn, x::Vector{T}, xScal::Vector{T}, opt::OptionsNLEQ)\n\n\nDamped Newton-algorithm with rank strategy for systems of highly nonlinear equations - damping strategy due to Ref.(1).\n\n\n(The iteration is done by function N2INT currently. NLEQ2 itself does some house keeping and builds up workspace.)\n\n\nJacobian approximation by numerical differences, user supplied function JAC or forward mode automatic differentation.\n\n\nThe numerical solution of the arising linear equations is done by means of the subroutines DECCON and SOLCON (QR de- composition with subcondition estimation, rank decision and computation of the rank-deficient pseudoinverse) . For special purposes these routines may be substituted.\n\n\nThis is a driver routine for the core solver N2INT.\n\n\nDoes not support Band mode for Jacobian storage.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfcn\n\n\nFunction for which zero is to be found. Should be in the form of fcn(y,x) with y = f(x).\n\n\n\n\n\n\nx[1:n]\n\n\nInitial estimate of the solution.\n\n\n\n\n\n\nxScal[1:n]\n\n\nUser scaling (lower threshold) of the iteration vector x\n\n\n\n\n\n\nopt\n\n\nOptions for solving the nonlinear system. Valid options are listed below.\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx0[1:n]\n\n\nSolution values (or final values if exit before solution is reached).\n\n\n\n\n\n\nstats\n\n\nA dictionary variable of additional output values. The fields are discussed below.\n\n\n\n\n\n\nretCode\n\n\nAn integer value signifying the exit code. The meaning of the exit codes are discussed below.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.n2int\n \u2014 \nFunction\n.\n\n\nfunction n2int{T}(n::Int64, fcn, x::Vector{T}, xScal::Vector{T},     rTol::T, nItmax::Int64, nonLin::Int64, iRank::Int64, cond::T,     opt::OptionsNLEQ, m1::Int64, m2::Int64, nBroy::Int64,     fc::T, fcMin::T, sigma::T, sigma2::T, mPrWarn::Int64,     mPrMon::Int64, mPrSol::Int64, printIOwarn, printIOmon, printIOsol, qBDamp::Bool)\n\n\nCore routine for NLEQ2.\n\n\nDamped Newton-algorithm with rank-strategy for systems of highly nonlinear equations especially designed for numerically sensitive problems.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of vector components\n\n\n\n\n\n\nfcn\n\n\nFunction for which zero is to be found. Should be in the form of fcn(y,x) with y = f(x).\n\n\n\n\n\n\nx[1:n]*\n\n\nInitial estimate of the solution.\n\n\n\n\n\n\nxScal[1:n]\n\n\nUser scaling (lower threshold) of the iteration vector x\n\n\n\n\n\n\nrTol\n\n\nRequired relative precision of solution components\n\n\n\n\n\n\nnItmax\n\n\nMaximum number of allowed iterations\n\n\n\n\n\n\nnonLin\n\n\nProblem type specification. See OPT_NONLIN field in solver options\n\n\n\n\n\n\niRank\n\n\nInitially proposed (in) and final (out) rank of Jacobian\n\n\n\n\n\n\ncond\n\n\nMaximum permitted subcondition for rank-decision by linear solver.\n\n\n\n\n\n\nopt\n\n\nOptions for solving the nonlinear system. Valid options are listed below.\n\n\n\n\n\n\nm1\n\n\nLeading dimension of Jacobian array a\n\n\n\n\n\n\nm2 = n\n\n\nFor full mode\n\n\n\n\n\n\n= ml+mu+1\n\n\nFor band mode\n\n\n\n\n\n\nnBroy\n\n\nMaximum possible consecutive iterative Broyden steps.\n\n\n\n\n\n\nfc\n\n\nCurrent Newton iteration damping factor.\n\n\n\n\n\n\nfcMin\n\n\nMinimum permitted damping factor. fc < fcMin results in either of the following\n\n\n\n\n\n\n\n\na. Recomputation of the Jacobian using difference approximation\n\n\n\n\n\n\n\n\nb. Fail exit\n\n\n\n\n\n\nsigma\n\n\nDecision parameter for rank1-updates\n\n\n\n\n\n\nsigma2\n\n\nDecision parameter for damping factor increasing to corrector\n\n\n\n\n\n\nmStor\n\n\nDecision parameter for matrix storage. See option OPT_MSTOR in solver options.\n\n\n\n\n\n\nmPrWarn\n\n\nDecision parameter for printing warning messages\n\n\n\n\n\n\nmPrMon\n\n\nDecision parameter for printing iteration monitor\n\n\n\n\n\n\nmPrSol\n\n\nDecision parameter for printing solution\n\n\n\n\n\n\nprintIOwarn\n\n\nIO handle for printing warning\n\n\n\n\n\n\nprintIOmon\n\n\nIO handle for printing iteration monitor\n\n\n\n\n\n\nprintIOsol\n\n\nIO handle for printing solution\n\n\n\n\n\n\nqBDamp\n\n\nDecision parameter for matrix storage. See option OPT_MSTOR in solver options.\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx[1:n]*\n\n\nSolution values (or final values if exit before solution is reached).\n\n\n\n\n\n\nretCode\n\n\nAn integer value signifying the exit code. The meaning of the exit codes are discussed below.\n\n\n\n\n\n\n\n\nsource",
            "title": "NLEQ2"
        },
        {
            "location": "/functions/common/",
            "text": "#\n\n\nNewtonMethods.checkOptions\n \u2014 \nFunction\n.\n\n\nfunction checkOptions{T}(n::Int64, x::Vector{T}, xScal::Vector{T},     opt::OptionsNLEQ)\n\n\nChecking of common input parameters and options.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nSize of the problem\n\n\n\n\n\n\nx\n\n\nInitial guess\n\n\n\n\n\n\nxScal*\n\n\nInitial scaling vector\n\n\n\n\n\n\nopt*\n\n\nOptions set by the user\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nretCode\n\n\nExit code in case of errors\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.initializeOptions\n \u2014 \nFunction\n.\n\n\nfunction initializeOptions\u00b7(opt::OptionsNLEQ, wk::OptionsNLEQ, n::Int64,     m1::Int64, nBroy::Int64, qRank1::Bool, solver::Int64, T::DataType)\n\n\nInitialization of options based on the solver input argument.\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nopt*\n\n\nOptions set by the user\n\n\n\n\n\n\nwk*\n\n\nInternal workspace specific to the solver\n\n\n\n\n\n\nn\n\n\nSize of the problem\n\n\n\n\n\n\nm1\n\n\nIn full mode = n and in band mode = 2*ml+mu+1\n\n\n\n\n\n\nnBroy\n\n\nMaximum number of possible consecutive iterative Broyden steps\n\n\n\n\n\n\nqRank1\n\n\nDecision parameter for Rank-1 updates\n\n\n\n\n\n\nsolver = 1\n\n\nSpecifies that the solver is NLEQ1\n\n\n\n\n\n\n= 2\n\n\nSpecifies that the solver is NLEQ2\n\n\n\n\n\n\nT\n\n\nData type of the input. Acceptable values Float64 or BigFloat\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nsource\n\n\nfunction initializeOptions(opt::OptionsNLEQ, solver::Int64, T::DataType)\n\n\nInitialization of options based on the solver input argument.\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nopt*\n\n\nOptions set by the user\n\n\n\n\n\n\nsolver = 1\n\n\nSpecifies that the solver is NLEQ1\n\n\n\n\n\n\n= 2\n\n\nSpecifies that the solver is NLEQ2\n\n\n\n\n\n\nT\n\n\nData type of the input. Acceptable values Float64 or BigFloat\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nsource\n\n\n#\n\n\nNewtonMethods.printInitialization\n \u2014 \nFunction\n.\n\n\nfunction printInitialization{T}(n::Int64, printIOmon, rTol::T, jacGen::Int64,     mStor::Int64, ml::Int64, mu::Int64, qNoRowScal::Int64, qRank1::Bool, nonLin::Int64,     qBDamp::Bool, fcBand::T, qOrdi::Bool, qSimpl::Bool, nItmax::Int64)\n\n\nPrint a summary of the initialization.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nSize of the problem\n\n\n\n\n\n\nprintIOmon\n\n\nIO handle for printing\n\n\n\n\n\n\nrTol\n\n\nRelative tolerance\n\n\n\n\n\n\njacGen\n\n\nMethod of Jacobian generation\n\n\n\n\n\n\nmStor\n\n\nDense or band mode storage of Jacobian\n\n\n\n\n\n\nml\n\n\nLower bandwidth in case of band storage\n\n\n\n\n\n\nmu\n\n\nUpper bandwidth in case of band storage\n\n\n\n\n\n\nqNoRowScal\n\n\nDecision parameter for automatic row scaling\n\n\n\n\n\n\nqRank1\n\n\nDecision parameter for Rank-1 updates\n\n\n\n\n\n\nnonLin\n\n\nProblem type specification\n\n\n\n\n\n\nqBDamp\n\n\nDecision parameter for bounded damping strategy\n\n\n\n\n\n\nfcBand\n\n\nBounded damping strategy restriction factor\n\n\n\n\n\n\nqOrdi\n\n\nDecision parameter for ordinary Newton iteration\n\n\n\n\n\n\nqSimpl\n\n\nDecision parameter for simplified Newton iteration\n\n\n\n\n\n\nnItmax\n\n\nMaximum permitted Newton iterations\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.printStats\n \u2014 \nFunction\n.\n\n\nfunction printStats(stats::Dict{AbstractString,Any}, printIOmon)\n\n\nPrint a summary of the statistics.\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstats\n\n\nDictionary variable containing solver statistics\n\n\n\n\n\n\nprintIOmon\n\n\nIO handle for printing\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nScal\n \u2014 \nFunction\n.\n\n\nfunction nScal{T}(n::Int64, x::Vector{T}, xa::Vector{T}, xScal::Vector{T},     iScal::Int64, mPr::Int64, printIO, xw::Vector{T})\n\n\nTo be used in connection with NLEQ1 and NLEQ2. Computation of the internal scaling vector XW used for the Jacobian matrix, the iterate vector and it's related vectors - especially for the solution of the linear system and the computations of norms to avoid numerical overflow.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nSize of the problem\n\n\n\n\n\n\nx\n\n\nCurrent iterate\n\n\n\n\n\n\nxa\n\n\nPrevious iterate\n\n\n\n\n\n\nxScal\n\n\nScaling vector\n\n\n\n\n\n\niScal\n\n\nDecision parameter for scaling\n\n\n\n\n\n\nmPr\n\n\nDecision parameter for printing\n\n\n\n\n\n\nprintIO\n\n\nIO handle for printing\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nxw\n\n\nScaling vector computed by this routine\nAll components must be positive.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nScrf\n \u2014 \nFunction\n.\n\n\nfunction nScrf{T}(m::Int64, n::Int64, a::Array{T,2}, fw::Vector{T})\n\n\nRow scaling of a (m,n)-matrix in full storage mode\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nm\n\n\nNumber of rows of the matrix\n\n\n\n\n\n\nn\n\n\nNumer of columns of the matrix\n\n\n\n\n\n\na[m,n]*\n\n\nMatrix to be scaled\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfw\n\n\nRow scaling factors.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nScrb\n \u2014 \nFunction\n.\n\n\nfunction nScrb{T}(n::Int64, lda::Int64, ml::Int64, mu::Int64, a::Array{T,2},     fw::Vector{T})\n\n\nRow scaling of a (n,n)-matrix in band storage mode\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of rows and columns of the matrix\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the matrix array\n\n\n\n\n\n\nml\n\n\nLower bandwidth of the matrix\n\n\n\n\n\n\nmu\n\n\nUpper bandwidth of the matrix\n\n\n\n\n\n\na[lda,n]*\n\n\nMatrix to be scaled\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfw\n\n\nRow scaling factors.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nLvls\n \u2014 \nFunction\n.\n\n\nfunction nLvls{T}(n::Int64, dxq::Vector{T}, dx1::Vector{T},     xw::Vector{T}, f::Vector{T}, qdscal::Bool)\n\n\nProvides descaled solution, error norm and level functions To be used in connection with NLEQ1 and NLEQ2.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNumber of parameters to be estimated\n\n\n\n\n\n\ndx1\n\n\nScaled Newton correction\n\n\n\n\n\n\nxw\n\n\nVector of scaling values\n\n\n\n\n\n\nf\n\n\nResidual vector\n\n\n\n\n\n\nqdscal\n\n\ntrue of descaling of dx1 required, else false\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndxq\n\n\nLeading dimension of the matrix array\n\n\n\n\n\n\nconv\n\n\nScaled maximum norm of Newton correction\n\n\n\n\n\n\nsumX\n\n\nScaled natural level function value\n\n\n\n\n\n\ndLevF\n\n\nStandard level function value\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nPrv1\n \u2014 \nFunction\n.\n\n\nfunction nPrv1{T}(dlevf::T, dlevx::T, fc::T, niter::Int64,     newt::Int64, mPr::Int64, printIO, qMixIO::Bool)\n\n\nPrinting of intermediate values (Type 1 routine)\n\n\nT = Float64 or BigFloat\n\n\nParameters\n\n\n\n\nFor all the parameters check n1int\n\n\nsource\n\n\nfunction nPrv1{T}(dlevf::T, dlevx::T, fc::T, niter::Int64, newt::Int64,     iRank::Int64, mPr::Int64, printIO, qMixIO::Bool, cond1::T)\n\n\nPrinting of intermediate values (Type 1 routine)\n\n\nT = Float64 or BigFloat\n\n\nParameters\n\n\nFor all the parameters check n2int\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nPrv2\n \u2014 \nFunction\n.\n\n\nfunction nPrv2{T}(dlevf::T, dlevx::T, fc::T, niter::Int64,     printIO, qMixIO::Bool, cmark::AbstractString)\n\n\nPrinting of intermediate values (Type 2 routine)\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndlevf\n\n\nStandard level function value\n\n\n\n\n\n\ndlevx\n\n\nStandard level value\n\n\n\n\n\n\nfc\n\n\nCurrent damping factor\n\n\n\n\n\n\nniter\n\n\nCurrent number of Newton iterations\n\n\n\n\n\n\nqMixIO\n\n\nDecision parameter for printing\n\n\n\n\n\n\ncmark\n\n\nMarker character to be printed before dlevx\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nSout\n \u2014 \nFunction\n.\n\n\nfunction nSout{T}(n::Int64, x::Vector{T}, mode::Int64, mPr::Int64, printIO,     nIter::Int64, dLevF::T, sumX::T)\n\n\nPrinting of iterate (user customizable routine)\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nSize of the problem\n\n\n\n\n\n\nx\n\n\nIterate vector\n\n\n\n\n\n\nmode = 1\n\n\nThis routine is called before the first Newton iteration step\n\n\n\n\n\n\n= 2\n\n\nThis routine is called with an intermediate iterate x\n\n\n\n\n\n\n= 3\n\n\nThis is the last call with the solution vector x\n\n\n\n\n\n\n= 4\n\n\nThis is the last call with the final, but not solution vector x\n\n\n\n\n\n\nmPr\n\n\nDecision parameter for printing\n\n\n\n\n\n\nprintIO\n\n\nIO handle for printing\n\n\n\n\n\n\nnIter\n\n\nCurrent number of Newton iterations\n\n\n\n\n\n\ndLevF\n\n\nStandard level function value\n\n\n\n\n\n\nsumX\n\n\nScaled natural level function value\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.wnorm\n \u2014 \nFunction\n.\n\n\nfunction wnorm{T}(n::Int64, z::Vector{T}, xw::Vector{T})\n\n\nReturn the norm to be used in exit (termination) criteria\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariables\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nSize of the problem\n\n\n\n\n\n\nz\n\n\nThe vector of which norm is to be computed\n\n\n\n\n\n\nxw\n\n\nScaling value of z\n\n\n\n\n\n\n\n\nOutput\n\n\n\n\nThe mean square root norm of z subject to the scaling values in xw.\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nJacFD\n \u2014 \nFunction\n.\n\n\nfunction nJacFD{T}(fcn, n::Int64, lda::Int64, x::Vector{T}, fx::Vector{T},     yscal::Vector{T}, ajdel::T, ajmin::T, nFcn::Int64,     a::Array{T,2})\n\n\nEvaluation of a dense Jacobian matrix using finite difference approximation adapted for use in nonlinear systems solver.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfcn\n\n\nFunction of the form fcn(f, x) to provide right-hand side\n\n\n\n\n\n\nn\n\n\nNumber of rows and columns of the Jacobian\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the array \"a\"\n\n\n\n\n\n\nx[n]\n\n\nCurrent scaled vector\n\n\n\n\n\n\nfx[n]\n\n\nVector containing fcn(x)\n\n\n\n\n\n\nyscal[n]\n\n\nVector containing scaling factors\n\n\n\n\n\n\najdel\n\n\nPerturbation of component k: abs(y(k))*ajdel\n\n\n\n\n\n\najmin\n\n\nMinimum perturbation is ajmin*ajdel\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na[lda,n]\n\n\nArray containing the approximated Jacobian\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count adjusted\n\n\n\n\n\n\niFail\n\n\nReturn code non-zero if Jacobian could not be computed\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nJacFDb\n \u2014 \nFunction\n.\n\n\nfunction nJacFDb{T}(fcn, n::Int64, lda::Int64, ml::Int64, x::Vector{T},     fx::Vector{T}, yscal::Vector{T}, ajdel::T, ajmin::T,     nFcn::Int64, a::Array{T,2})\n\n\nEvaluation of a banded Jacobian matrix using finite difference approximation adapted for use in nonlinear systems solver\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfcn\n\n\nFunction of the form fcn(f, x) to provide right-hand side\n\n\n\n\n\n\nn\n\n\nNumber of rows and columns of the Jacobian\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the array \"a\"\n\n\n\n\n\n\nml\n\n\nLower bandwidth of the Jacobian matrix\n\n\n\n\n\n\nx[n]\n\n\nCurrent scaled vector\n\n\n\n\n\n\nfx[n]\n\n\nVector containing fcn(x)\n\n\n\n\n\n\nyscal[n]\n\n\nVector containing scaling factors\n\n\n\n\n\n\najdel\n\n\nPerturbation of component k: abs(y(k))*ajdel\n\n\n\n\n\n\najmin\n\n\nMinimum perturbation is ajmin*ajdel\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na[lda,n]\n\n\nArray containing the approximated Jacobian\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count adjusted\n\n\n\n\n\n\niFail\n\n\nReturn code non-zero if Jacobian could not be computed\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nJcf\n \u2014 \nFunction\n.\n\n\nfunction nJcf{T}(fcn, n::Int64, lda::Int64, x::Vector{T}, fx::Vector{T},     yscal::Vector{T}, eta::Vector{T}, etamin::T, etamax::T,     etadif::T, conv::T, nFcn::Int64, a::Array{T,2})\n\n\nApproximation of dense Jacobian matrix for nonlinear systems solver with feed-back control of discretization and rounding errors\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfcn\n\n\nFunction of the form fcn(f, x) to provide right-hand side\n\n\n\n\n\n\nn\n\n\nNumber of rows and columns of the Jacobian\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the array \"a\"\n\n\n\n\n\n\nx[n]\n\n\nCurrent scaled vector\n\n\n\n\n\n\nfx[n]\n\n\nVector containing fcn(x)\n\n\n\n\n\n\nyscal[n]\n\n\nVector containing scaling factors\n\n\n\n\n\n\neta[n]*\n\n\nVector of scaled denominator differences\n\n\n\n\n\n\netamin\n\n\nMinimum allowed scaled denominator\n\n\n\n\n\n\netamax\n\n\nMaximum allowed scaled denominator\n\n\n\n\n\n\netadif\n\n\n= sqrt(1.1*epMach)\n\n\n\n\n\n\nconv\n\n\nMaximum norm of last (unrelaxed) Newton correction\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na[lda,n]\n\n\nArray containing the approximated Jacobian\n\n\n\n\n\n\neta[n]*\n\n\nVector of scaled denominator differences adjusted\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count adjusted\n\n\n\n\n\n\niFail\n\n\nReturn code non-zero if Jacobian could not be computed\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nJcfb\n \u2014 \nFunction\n.\n\n\nfunction nJcfb{T}(fcn, n::Int64, lda::Int64, ml::Int64, x::Vector{T},     fx::Vector{T}, yscal::Vector{T}, eta::Vector{T},     etamin::T, etamax::T, etadif::T, conv::T,     nFcn::Int64, a::Array{T,2})\n\n\nApproximation of banded Jacobian matrix for nonlinear systems solver with feed-back control of discretization and rounding errors\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfcn\n\n\nFunction of the form fcn(f, x) to provide right-hand side\n\n\n\n\n\n\nn\n\n\nNumber of rows and columns of the Jacobian\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the array \"a\"\n\n\n\n\n\n\nml\n\n\nLower bandwidth of the Jacobian matrix\n\n\n\n\n\n\nx[n]\n\n\nCurrent scaled vector\n\n\n\n\n\n\nfx[n]\n\n\nVector containing fcn(x)\n\n\n\n\n\n\nyscal[n]\n\n\nVector containing scaling factors\n\n\n\n\n\n\neta[n]*\n\n\nVector of scaled denominator differences\n\n\n\n\n\n\netamin\n\n\nMinimum allowed scaled denominator\n\n\n\n\n\n\netamax\n\n\nMaximum allowed scaled denominator\n\n\n\n\n\n\netadif\n\n\n= sqrt(1.1*epMach)\n\n\n\n\n\n\nconv\n\n\nMaximum norm of last (unrelaxed) Newton correction\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na[lda,n]\n\n\nArray containing the approximated Jacobian\n\n\n\n\n\n\neta[n]*\n\n\nVector of scaled denominator differences adjusted\n\n\n\n\n\n\nnFcn*\n\n\nfcn evaluation count adjusted\n\n\n\n\n\n\niFail\n\n\nReturn code non-zero if Jacobian could not be computed\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nFact\n \u2014 \nFunction\n.\n\n\nfunction nFact{T}(n::Int64, lda::Int64, ml::Int64, mu::Int64, a::Array{T,2},     mStor::Int64, l::Array{T,2}, u::Array{T,2}, p::Vector{Int64})\n\n\nCall linear algebra subprogram for factorization of a (n,n)-matrix.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nOrder of the linear system\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the matrix a\n\n\n\n\n\n\nml\n\n\nLower bandwidth of the matrix (only for banded systems)\n\n\n\n\n\n\nmu\n\n\nUpper bandwidth of the matrix (only for banded systems)\n\n\n\n\n\n\na[lda,n]\n\n\nMatrix to be factorized\n\n\n\n\n\n\nmStor = 0\n\n\nFull storage mode for matrix\n\n\n\n\n\n\nmStor = 1\n\n\nBand storage mode for matrix\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\niFail\n\n\nExit code in case of errors\n\n\n\n\n\n\n= 0\n\n\nMatrix decomposition successful\n\n\n\n\n\n\n= 1\n\n\nDecomposition failed - matrix numerically singular\n\n\n\n\n\n\nl[lda,n]\n\n\nLower triangular part of decomposed matrix in case of full mode. The complete LU-decomposition in band mode\n\n\n\n\n\n\nu[lda,n]\n\n\nUpper triangular part of decomposed matrix in case of full mode. Unused in case of band mode.\n\n\n\n\n\n\np\n\n\nVector of pivot indices\n\n\n\n\n\n\n\n\nsource\n\n\nfunction nFact{T}(n::Int64, lda::Int64, ldaInv::Int64, ml::Int64, mu::Int64,     a::Array{T,2}, aInv::Array{T,2}, cond::T, iRank::Int64,     opt::OptionsNLEQ, p::Vector{Int64}, d::Vector{T}, iRepeat::Int64, iRankC::Int64)\n\n\nCall linear algebra subprogram for factorization of a (n,n)-matrix with rank decision and casual computation of the rank deficient pseudo-inverse matrix.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nOrder of the linear system\n\n\n\n\n\n\nlda\n\n\nLeading dimension of the matrix a\n\n\n\n\n\n\nldaInv\n\n\nLeading dimension of the matrix aInv\n\n\n\n\n\n\nml\n\n\nLower bandwidth of the matrix (only for banded systems)\n\n\n\n\n\n\nmu\n\n\nUpper bandwidth of the matrix (only for banded systems)\n\n\n\n\n\n\na[lda,n]\n\n\nMatrix to be factorized\n\n\n\n\n\n\ncond*\n\n\nMaximum permitted subcondition for the prescribed rank\n\n\n\n\n\n\nopt\n\n\nUser prescribed options\n\n\n\n\n\n\niRankC, iRank, cond\n\n\nRefer to input and output parameters of deccon\n\n\n\n\n\n\niRank*\n\n\nPrescribed maximum pseudo-rank of matrix a\n\n\n\n\n\n\ncond*\n\n\nPermitted upper bound for the subcondition of leastsquares part of a\n\n\n\n\n\n\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naInv[ldaInv,n]\n\n\nIf matrix a is rank deficient this array holds the pseudo-inverse of a\n\n\n\n\n\n\niFail = 0\n\n\nMatrix decomposition successful\n\n\n\n\n\n\np\n\n\nVector of pivot indices\n\n\n\n\n\n\nd\n\n\nRefer to deccon\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.nSolv\n \u2014 \nFunction\n.\n\n\nfunction nSolv{T}(n::Int64, lda::Int64, ml::Int64, mu::Int64, l::Array{T,2},     u::Array{T,2}, p::Vector{Int64}, b::Vector{T}, mStor::Int64)\n\n\nCall linear algebra subprogram for solution of the linear system a*z = b\n\n\nT = Float64 or BigFloat\n\n\nParameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn, lda, ml, mu, l, u, p, b, mStor, iFail\n\n\nRefer nFact\n\n\n\n\n\n\n\n\nsource\n\n\nfunction nSolv{T}(n::Int64, lda::Int64, ldaInv::Int64, ml::Int64, mu::Int64,     a::Array{T,2}, aInv::Array{T,2}, b::Vector{T},     z::Vector{T}, iRank::Int64, iRepeat::Int64, d::Vector{T},     pivot::Vector{Int64}, iRankC::Int64)\n\n\nCall linear algebra subprogram for solution of the linear system a*z = b. To be used with the factorization routine of a (n,n)-matrix with rank decision and casual computation of the rank deficient pseudo-inverse matrix.\n\n\nT = Float64 or BigFloat\n\n\nInput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nb[n]*\n\n\nRight hand side of the linear system\n\n\n\n\n\n\nn, lda, ldaInv, ml, mu, a, aInv, iRank, iRepeat, d, pivot, iRankC\n\n\nRefer nFact\n\n\n\n\n\n\n\n\n(* marks inout parameters)\n\n\nOutput parameters\n\n\n\n\n\n\n\n\n\n\nVariable\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nb[n]*\n\n\nRHS transformed to the upper triangular part of the linear system\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nNewtonMethods.AbstractOptionsNLEQ\n \u2014 \nType\n.\n\n\nsuper-type for all types storing options for NLEQ solvers.\n\n\nNLEQ solvers often have serveral parameters for fine-tuning them. In this NLEQInterface this parameters are called 'options' and they are stored in key/value paris. For the key a \nAbstractString\n is used. The value can be \nAny\n-thing. The key is often called the option-name.\n\n\nAll types for this purpose have this abstract type as super-type.\n\n\nRequired fields are: \nname\n, \nlastchanged\n, \noptions\n\n\nsource\n\n\n#\n\n\nNewtonMethods.OptionsNLEQ\n \u2014 \nType\n.\n\n\nStores options for NLEQ Solver(s) together with a name. Additionally the time of the last change is saved.\n\n\nOptions can be set at construction time, e.g.\n\n\nopt=OptionsNLEQ(\"test\", \"loglevel\" => NLEQ.LOG_ALL, \"logio\"    => STDERR)\n\n\nor later. For changing single options\n\n\noldValue = setOption!(opt,\"myopt\",\"new value\") oldValue = setOption!(opt,\"myopt\" => \"new value\")\n\n\nand for changing many options at once:\n\n\noldValues = setOption!(opt, \"myopt\" => \"new value\",     \"oldopt\" => 56)\n\n\nsee also: \nsetOption!\n, \nsetOptions!\n\n\nsource\n\n\n#\n\n\nNewtonMethods.getOption\n \u2014 \nFunction\n.\n\n\nfunction getOption(opt::AbstractOptionsNLEQ, name::AbstractString,     default::Any=nothing)\n\n\nget saved value of option with given \nname\n or set option to \ndefault\n if option is unknown.\n\n\nsource\n\n\n#\n\n\nNewtonMethods.getOption!\n \u2014 \nFunction\n.\n\n\nfunction getOption!(opt::AbstractOptionsNLEQ, name::AbstractString,     default::Any=nothing)\n\n\nfunction to get value and set default value in case no value was present This avoids the recursive calls to setOption and getOption\n\n\nsource\n\n\n#\n\n\nNewtonMethods.setOption!\n \u2014 \nFunction\n.\n\n\nfunction setOption!(opt::AbstractOptionsNLEQ, name::AbstractString, value::Any)\n\n\nset NLEQ-Option with given \nname\n and return old value (or \nnothing\n if there was no old value).\n\n\nsource\n\n\nfunction setOption!(opt::AbstractOptionsNLEQ, pair::Pair)\n\n\nset NLEQ-Option with given (\nname\n,\nvalue\n) pair and return old value (or \nnothing\n if there was no old value).\n\n\nsource\n\n\n#\n\n\nNewtonMethods.setOptions!\n \u2014 \nFunction\n.\n\n\nfunction setOptions!(opt::AbstractOptionsNLEQ, pairs::Pair...)\n\n\nset many NLEQ-Options and return an array with the old option values.\n\n\nsource\n\n\n#\n\n\nNewtonMethods.initOption!\n \u2014 \nFunction\n.\n\n\nfunction initOption!(opt::AbstractOptionsNLEQ, name::AbstractString, value::Any)\n\n\ninitialize NLEQ-Option with given \nname\n only if it does not exist already and return the old value if changed (or \nnothing\n if there was an old value).\n\n\nsource\n\n\nfunction initOption!(opt::AbstractOptionsNLEQ, pair::Pair)\n\n\ninitialize NLEQ-Option with given (\nname\n,\nvalue\n) pair only if it does not exist already and return the old value if changed (or \nnothing\n if there was an old value).\n\n\nsource\n\n\n#\n\n\nNewtonMethods.initOptions!\n \u2014 \nFunction\n.\n\n\nfunction initOptions!(opt::AbstractOptionsNLEQ, pairs::Pair...)\n\n\ninitialize many NLEQ-Options and return an array with the old option values if the options did not exist before\n\n\nsource\n\n\n#\n\n\nNewtonMethods.copyOptions!\n \u2014 \nFunction\n.\n\n\nfunction copyOptions!(dest::AbstractOptionsNLEQ, source::AbstractOptionsNLEQ)\n\n\ncopy all options from other NLEQ-Option object.\n\n\nsource\n\n\n#\n\n\nNewtonMethods.getMachineConstants\n \u2014 \nFunction\n.\n\n\nfunction getMachineConstants(T::DataType)\n\n\nGet the machine constants depending on the DataType T.\n\n\nSupported DataTypes are Float64 and BigFloat.\n\n\nsource\n\n\n#\n\n\nNewtonMethods.clearWorkspace\n \u2014 \nFunction\n.\n\n\nfunction clearWorkspace(name::AbstractString)\n\n\nFunction used to clear a workspace.\n\n\nInput parameter\n\n\nname\n is the string which signifies which workspace is to be cleared.\n\n\nFor clearing the workspace related to NLEQ1 the following three strings are valid: \nNLEQ1\n, \nnleq1\n, and \nNleq1\n.\n\n\nFor clearing the workspace related to NLEQ2 the following three strings are valid: \nNLEQ2\n, \nnleq2\n, and \nNleq2\n\n\nsource\n\n\nfunction clearWorkspace()\n\n\nFunction used to clear all workspaces.\n\n\nsource",
            "title": "Common"
        },
        {
            "location": "/options/",
            "text": "Common options\n\n\n\n\n\n\n\n\nName\n\n\nDefault value\n\n\nValue\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOPT_RTOL\n\n\n1e-6\n\n\n\n\nRequired relative precision of solution components.\n\n\n\n\n\n\nOPT_QSUCC\n\n\n0\n\n\n0\n\n\n(false) initial call: NLEQ solver is not yet initialized, i.e. this is the first call for this nonlinear system. At successful return with OPT_MODE=1, OPT_QSUCC is set to 1.\n\n\n\n\n\n\n\n\n\n\n1\n\n\n(true) successive call: NLEQ solver is initialized already and is now called to perform one or more following Newton iteration steps.\n\n\n\n\n\n\nOPT_MODE\n\n\n0\n\n\n0\n\n\nStandard mode initial call: Return when the required accuracy for the iteration vector is reached. User defined parameters are evaluated and checked.\n\n\n\n\n\n\n\n\n\n\n0\n\n\nStandard mode successive call: If NLEQ solver was called previously with OPT_MODE=1, it performs all remaining iteration steps.\n\n\n\n\n\n\n\n\n\n\n1\n\n\nStepwise mode: Return after one Newton iteration step.\n\n\n\n\n\n\nOPT_JACGEN\n\n\n2\n\n\n1\n\n\nUser supplied subroutine OPT_JACFCN will be called to generate Jacobian matrix\n\n\n\n\n\n\n\n\n\n\n2\n\n\nJacobian approximation by numerical differentation (see subroutines nJac and nJacb)\n\n\n\n\n\n\n\n\n\n\n3\n\n\nJacobian approximation by numerical differentation with feedback control (see subroutines nJcf and nJcfb)\n\n\n\n\n\n\n\n\n\n\n4\n\n\nJacobian approximation by forward mode automatic differentiation using the ForwardDiff package\n\n\n\n\n\n\nOPT_JACFCN\n\n\n0\n\n\n\n\nUser supplied Jacobian generation function of the form Jac(a,x), where a = Jacobian(x). Only required if OPT_JACGEN = 2\n\n\n\n\n\n\nOPT_MSTOR\n\n\n0\n\n\n0\n\n\nJacobian is a dense matrix\n\n\n\n\n\n\n\n\n\n\n1\n\n\nJacobian is a band matrix\n\n\n\n\n\n\nOPT_ML\n\n\n0\n\n\n\n\nLower bandwidth of the Jacobian (excluding the diagonal). Only required if OPT_MSTOR = 1\n\n\n\n\n\n\nOPT_MU\n\n\n0\n\n\n\n\nUpper bandwidth of the Jacobian (excluding the diagonal). Only required if OPT_MSTOR = 1\n\n\n\n\n\n\nOPT_ISCAL\n\n\n0\n\n\n0\n\n\nThe user supplied scaling vector XSCAL is used as a (componentwise) lower threshold of the current scaling vector\n\n\n\n\n\n\n\n\n\n\n1\n\n\nThe vector xScal is always used as the current scaling vector\n\n\n\n\n\n\nOPT_PRINTWARNING\n\n\n0\n\n\n0\n\n\nDo not print any warning or error messages\n\n\n\n\n\n\n\n\n\n\n1\n\n\nPrint warning and error messages\n\n\n\n\n\n\nOPT_PRINTITERATION\n\n\n0\n\n\n0\n\n\nDo not print iteration monitor\n\n\n\n\n\n\n\n\n\n\n1\n\n\nStandard output\n\n\n\n\n\n\n\n\n\n\n2\n\n\nSummary iteration monitor additionally\n\n\n\n\n\n\n\n\n\n\n3\n\n\nDetailed iteration monitor additionally\n\n\n\n\n\n\n\n\n\n\n4,5,6\n\n\nOutputs with increasing level additional increasing information for code testing purposes. Level 6 produces in general extremely large output!\n\n\n\n\n\n\nOPT_PRINTSOLUTION\n\n\n0\n\n\n0\n\n\nDo not print solutions\n\n\n\n\n\n\n\n\n\n\n1\n\n\nPrint initial values and solution values\n\n\n\n\n\n\n\n\n\n\n2\n\n\nPrint intermediate values additionally\n\n\n\n\n\n\nOPT_PRINTIOWARN\n\n\n0\n\n\n0\n\n\nPrints the warning and error messages to STDOUT\n\n\n\n\n\n\n\n\n\n\nIOStream\n\n\nPrints the warning and error messages to the file provided. Please look at the examples to understand this option.\n\n\n\n\n\n\nOPT_PRINTIOMON\n\n\n0\n\n\n0\n\n\nPrints the iteration monitor to STDOUT\n\n\n\n\n\n\n\n\n\n\nIOStream\n\n\nPrints the iteration monitor to the file provided. Please look at the examples to understand this option.\n\n\n\n\n\n\nOPT_PRINTIOSOL\n\n\n0\n\n\n0\n\n\nPrints the solutions to STDOUT\n\n\n\n\n\n\n\n\n\n\nIOStream\n\n\nPrints the solutions to the file provided. Please look at the examples to understand this option.\n\n\n\n\n\n\nOPT_NONLIN\n\n\n3\n\n\n1\n\n\nLinear problem.\nWarning: If specified, no check will be done, if the problem is really linear, and the NLEQ solver terminates unconditionally after one Newton-iteration step.\n\n\n\n\n\n\n\n\n\n\n2\n\n\nMildly nonlinear problem\n\n\n\n\n\n\n\n\n\n\n3\n\n\nHighly nonlinear problem\n\n\n\n\n\n\n\n\n\n\n4\n\n\nExtremely nonlinear problem\n\n\n\n\n\n\nOPT_QRANK1\n\n\n0\n\n\n0\n\n\n(false) Rank-1 updates by Broyden-approximation are inhibited.\n\n\n\n\n\n\n\n\n\n\n1\n\n\n(true) Rank-1 updates by Broyden-approximation are allowed.\n\n\n\n\n\n\nOPT_QORDI\n\n\n0\n\n\n0\n\n\n(false) Standard program mode.\n\n\n\n\n\n\n\n\n\n\n1\n\n\n(true) Special program mode: Ordinary Newton iteration is done, e.g.: No damping strategy and no monotonicity test is applied.\n\n\n\n\n\n\nOPT_QSIMPL\n\n\n0\n\n\n0\n\n\n(false) Standard program mode\n\n\n\n\n\n\n\n\n\n\n1\n\n\n(true)  Special program mode: Simplified Newton iteration is done, e.g.: The Jacobian computed at the starting point is fixed for all subsequent iteration steps, and no damping strategy and no monotonicity test is applied.\n\n\n\n\n\n\nOPT_NOROWSCAL\n\n\n0\n\n\n0\n\n\n(false) Automatic row scaling of the linear system is active:\n Rows i=1,...,n will be divided by max j=1,...,n (abs(a[i,j]))\n\n\n\n\n\n\n\n\n\n\n1\n\n\n(true) No row scaling of the linear system. Recommended only for well scaled nonlinear systems.\n\n\n\n\n\n\nOPT_BOUNDEDDAMP\n\n\n0\n\n\n0\n\n\nThe default bounded damping strategy switch takes place, dependent on the setting of OPT_NONLIN :\nOPT_NONLIN = 0,1,2,3 -> OPT_BOUNDEDDAMP = off,\nOPT_NONLIN = 4 -> OPT_BOUNDEDDAMP = on\n\n\n\n\n\n\n\n\n\n\n1\n\n\nmeans always OPT_BOUNDEDDAMP = on\n\n\n\n\n\n\n\n\n\n\n2\n\n\nmeans always OPT_BOUNDEDDAMP = off\n\n\n\n\n\n\nOPT_IORMON\n\n\n2\n\n\n1\n\n\nConvergence order is not checked, the iteration will be always proceeded until the solution has the required precision OPT_RTOL (or some error condition occured)\n\n\n\n\n\n\n\n\n\n\n2\n\n\nUse additional 'weak stop' criterion: Convergence order is monitored and termination due to slowdown of the convergence may occur.\n\n\n\n\n\n\n\n\n\n\n3\n\n\nUse additional 'hard stop' criterion: Convergence order is monitored and termination due to superlinear convergence slowdown may occur.\n\n\n\n\n\n\n\n\n\n\n\n\nIn case of termination due to convergence slowdown, the warning code retCode=4 will be set. In cases, where the Newton iteration converges but superlinear convergence order has never been detected, the warning code retCode=5 is returned.\n\n\n\n\n\n\nOPT_NITMAX\n\n\n50\n\n\n\n\nMaximum number of permitted iteration steps\n\n\n\n\n\n\nOPT_FCBAND\n\n\n10.0\n\n\n\n\nBounded damping strategy restriction factor\n\n\n\n\n\n\nOPT_SIGMA\n\n\n\n\n\n\nBroyden-approximation decision parameter. Required choice: OPT_SIGMA >= 1. Increasing this parameter make it less probable that the algorithm performs rank-1 updates. Rank-1 updates are inhibited, if OPT_SIGMA > 1/OPT_FCMIN is set. (see note 4)\n\n\n\n\n\n\nOPT_SIGMA2\n\n\n\n\n\n\nDecision parameter about increasing damping factor to corrector if predictor is small. Required choice: OPT_SIGMA2 > 1. Increasing this parameter make it less probable that the algorithm performs rank-1 updates.\n\n\n\n\n\n\nOPT_AJDEL\n\n\nsqrt(epMach*10)\n\n\n\n\nJacobian approximation without feedback: Relative pertubation for components. epMach: relative machine precision)\n\n\n\n\n\n\nOPT_AJMIN\n\n\n0.0\n\n\n\n\nJacobian approximation without feedback: Threshold value. The absolute pertubation for component k is computed by delx := OPT_AJDEL*max(abs(x[k]),OPT_AJMIN)\n\n\n\n\n\n\nOPT_ETADIF\n\n\n1e-6\n\n\n\n\nJacobian approximation with feedback: Target value for relative pertubation eta of x\n\n\n\n\n\n\nOPT_ETAINI\n\n\n1e-6\n\n\n\n\nJacobian approximation with feedback: Initial value for denominator differences\n\n\n\n\n\n\nOPT_NBROY\n\n\n\n\n\n\nMaximum number of possible consecutive iterative Broyden steps. Default is n if OPT_MSTOR=0, and OPT_ML+OPT_MU+1 if OPT_MSTOR=1 (but minimum is always 10) provided that Broyden is allowed. If Broyden is inhibited, OPT_NBROY is always set to zero.\n\n\n\n\n\n\nOPT_FCSTART\n\n\n\n\n\n\nDamping factor for first Newton iteration: overrides option OPT_NONLIN, if set (see note 4)\n\n\n\n\n\n\nOPT_FCMIN\n\n\n\n\n\n\nMinimal allowed damping factor (see note 4)\n\n\n\n\n\n\nOPT_STORE\n\n\n0\n\n\n0\n\n\n(false) Do not store data related to iteration steps\n\n\n\n\n\n\n\n\n\n\n1\n\n\n(true) Store data related to iteration steps. (Check statistics for more details)\n\n\n\n\n\n\n\n\n\n\nOptions specific to NLEQ2\n\n\n\n\n\n\n\n\nName\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nOPT_IRANK\n\n\nInitially proposed (in) and final (out) rank of Jacobian\n\n\n\n\n\n\nOPT_COND\n\n\nMaximum permitted subcondition for rank-decision by linear solver.",
            "title": "Solver Options"
        },
        {
            "location": "/options/#common-options",
            "text": "Name  Default value  Value  Meaning      OPT_RTOL  1e-6   Required relative precision of solution components.    OPT_QSUCC  0  0  (false) initial call: NLEQ solver is not yet initialized, i.e. this is the first call for this nonlinear system. At successful return with OPT_MODE=1, OPT_QSUCC is set to 1.      1  (true) successive call: NLEQ solver is initialized already and is now called to perform one or more following Newton iteration steps.    OPT_MODE  0  0  Standard mode initial call: Return when the required accuracy for the iteration vector is reached. User defined parameters are evaluated and checked.      0  Standard mode successive call: If NLEQ solver was called previously with OPT_MODE=1, it performs all remaining iteration steps.      1  Stepwise mode: Return after one Newton iteration step.    OPT_JACGEN  2  1  User supplied subroutine OPT_JACFCN will be called to generate Jacobian matrix      2  Jacobian approximation by numerical differentation (see subroutines nJac and nJacb)      3  Jacobian approximation by numerical differentation with feedback control (see subroutines nJcf and nJcfb)      4  Jacobian approximation by forward mode automatic differentiation using the ForwardDiff package    OPT_JACFCN  0   User supplied Jacobian generation function of the form Jac(a,x), where a = Jacobian(x). Only required if OPT_JACGEN = 2    OPT_MSTOR  0  0  Jacobian is a dense matrix      1  Jacobian is a band matrix    OPT_ML  0   Lower bandwidth of the Jacobian (excluding the diagonal). Only required if OPT_MSTOR = 1    OPT_MU  0   Upper bandwidth of the Jacobian (excluding the diagonal). Only required if OPT_MSTOR = 1    OPT_ISCAL  0  0  The user supplied scaling vector XSCAL is used as a (componentwise) lower threshold of the current scaling vector      1  The vector xScal is always used as the current scaling vector    OPT_PRINTWARNING  0  0  Do not print any warning or error messages      1  Print warning and error messages    OPT_PRINTITERATION  0  0  Do not print iteration monitor      1  Standard output      2  Summary iteration monitor additionally      3  Detailed iteration monitor additionally      4,5,6  Outputs with increasing level additional increasing information for code testing purposes. Level 6 produces in general extremely large output!    OPT_PRINTSOLUTION  0  0  Do not print solutions      1  Print initial values and solution values      2  Print intermediate values additionally    OPT_PRINTIOWARN  0  0  Prints the warning and error messages to STDOUT      IOStream  Prints the warning and error messages to the file provided. Please look at the examples to understand this option.    OPT_PRINTIOMON  0  0  Prints the iteration monitor to STDOUT      IOStream  Prints the iteration monitor to the file provided. Please look at the examples to understand this option.    OPT_PRINTIOSOL  0  0  Prints the solutions to STDOUT      IOStream  Prints the solutions to the file provided. Please look at the examples to understand this option.    OPT_NONLIN  3  1  Linear problem. Warning: If specified, no check will be done, if the problem is really linear, and the NLEQ solver terminates unconditionally after one Newton-iteration step.      2  Mildly nonlinear problem      3  Highly nonlinear problem      4  Extremely nonlinear problem    OPT_QRANK1  0  0  (false) Rank-1 updates by Broyden-approximation are inhibited.      1  (true) Rank-1 updates by Broyden-approximation are allowed.    OPT_QORDI  0  0  (false) Standard program mode.      1  (true) Special program mode: Ordinary Newton iteration is done, e.g.: No damping strategy and no monotonicity test is applied.    OPT_QSIMPL  0  0  (false) Standard program mode      1  (true)  Special program mode: Simplified Newton iteration is done, e.g.: The Jacobian computed at the starting point is fixed for all subsequent iteration steps, and no damping strategy and no monotonicity test is applied.    OPT_NOROWSCAL  0  0  (false) Automatic row scaling of the linear system is active:  Rows i=1,...,n will be divided by max j=1,...,n (abs(a[i,j]))      1  (true) No row scaling of the linear system. Recommended only for well scaled nonlinear systems.    OPT_BOUNDEDDAMP  0  0  The default bounded damping strategy switch takes place, dependent on the setting of OPT_NONLIN : OPT_NONLIN = 0,1,2,3 -> OPT_BOUNDEDDAMP = off, OPT_NONLIN = 4 -> OPT_BOUNDEDDAMP = on      1  means always OPT_BOUNDEDDAMP = on      2  means always OPT_BOUNDEDDAMP = off    OPT_IORMON  2  1  Convergence order is not checked, the iteration will be always proceeded until the solution has the required precision OPT_RTOL (or some error condition occured)      2  Use additional 'weak stop' criterion: Convergence order is monitored and termination due to slowdown of the convergence may occur.      3  Use additional 'hard stop' criterion: Convergence order is monitored and termination due to superlinear convergence slowdown may occur.       In case of termination due to convergence slowdown, the warning code retCode=4 will be set. In cases, where the Newton iteration converges but superlinear convergence order has never been detected, the warning code retCode=5 is returned.    OPT_NITMAX  50   Maximum number of permitted iteration steps    OPT_FCBAND  10.0   Bounded damping strategy restriction factor    OPT_SIGMA    Broyden-approximation decision parameter. Required choice: OPT_SIGMA >= 1. Increasing this parameter make it less probable that the algorithm performs rank-1 updates. Rank-1 updates are inhibited, if OPT_SIGMA > 1/OPT_FCMIN is set. (see note 4)    OPT_SIGMA2    Decision parameter about increasing damping factor to corrector if predictor is small. Required choice: OPT_SIGMA2 > 1. Increasing this parameter make it less probable that the algorithm performs rank-1 updates.    OPT_AJDEL  sqrt(epMach*10)   Jacobian approximation without feedback: Relative pertubation for components. epMach: relative machine precision)    OPT_AJMIN  0.0   Jacobian approximation without feedback: Threshold value. The absolute pertubation for component k is computed by delx := OPT_AJDEL*max(abs(x[k]),OPT_AJMIN)    OPT_ETADIF  1e-6   Jacobian approximation with feedback: Target value for relative pertubation eta of x    OPT_ETAINI  1e-6   Jacobian approximation with feedback: Initial value for denominator differences    OPT_NBROY    Maximum number of possible consecutive iterative Broyden steps. Default is n if OPT_MSTOR=0, and OPT_ML+OPT_MU+1 if OPT_MSTOR=1 (but minimum is always 10) provided that Broyden is allowed. If Broyden is inhibited, OPT_NBROY is always set to zero.    OPT_FCSTART    Damping factor for first Newton iteration: overrides option OPT_NONLIN, if set (see note 4)    OPT_FCMIN    Minimal allowed damping factor (see note 4)    OPT_STORE  0  0  (false) Do not store data related to iteration steps      1  (true) Store data related to iteration steps. (Check statistics for more details)",
            "title": "Common options"
        },
        {
            "location": "/options/#options-specific-to-nleq2",
            "text": "Name  Meaning      OPT_IRANK  Initially proposed (in) and final (out) rank of Jacobian    OPT_COND  Maximum permitted subcondition for rank-decision by linear solver.",
            "title": "Options specific to NLEQ2"
        },
        {
            "location": "/stats/",
            "text": "Statistics\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSTATS_XSCAL\n\n\nAfter return with retCode >= 0, it contains the latest internal scaling vector used. After return with retCode == -1 in onestep mode it contains a possibly adapted (as described below) user scaling vector:\n\n\n\n\n\n\n\n\nIf (xScal[i] <  small) xScal[i] = small \nIf (xScal[i] >  great) xScal[i] = great\n\n\n\n\n\n\nSTATS_RTOL\n\n\nFinally achieved (relative) accuracy. The estimated absolute error of component i of x_out is approximately given by abs_err[i] = rTol * xScal_out[i], where (approximately) xScal_out[i] = max(abs(x_out[i]),xScal_in[i]).\n\n\n\n\n\n\nSTATS_CONV\n\n\nThe achieved relative accuracy after the latest step\n\n\n\n\n\n\nSTATS_SUMX\n\n\nNatural level (not Normx of printouts) of the latest iterate, i.e. sum(dx.^2), where dx = scaled Newton correction.\n\n\n\n\n\n\nSTATS_DLEVF\n\n\nStandard level (not Normf of printouts) of the latest iterate, i.e. norm(f(x),2), where f =  nonlinear problem function.\n\n\n\n\n\n\nSTATS_SUBCOND\n\n\nSubcondition of the linear system as estimated by the linear solver (only in case of nleq2)\n\n\n\n\n\n\nSTATS_SENS\n\n\nSensitivity of the linear system as estimated by the linear solver (only in case of nleq2)\n\n\n\n\n\n\nSTATS_NITER\n\n\nNumber of Newton-iterations\n\n\n\n\n\n\nSTATS_NCORR\n\n\nNumber of corrector steps\n\n\n\n\n\n\nSTATS_NFCN\n\n\nNumber of fcn-evaluations\n\n\n\n\n\n\nSTATS_NFCNJ\n\n\nNumber of fcn-evaluations for Jacobian approximation\n\n\n\n\n\n\nSTATS_NJAC\n\n\nNumber of Jacobian generations or jac-calls\n\n\n\n\n\n\nSTATS_NREJR1\n\n\nNumber of rejected Newton iteration steps done with a rank-1 approximated Jacobian\n\n\n\n\n\n\nSTATS_NEW\n\n\nCount of consecutive rank-1 updates\n\n\n\n\n\n\nSTATS_ICONV\n\n\nCurrent status of of the convergence monitor (only if convergence order monitor is on see OPT_IORMON)\n=0: No convergence indicated yet\n=1: Damping factor is 1.0\n=2: Superlinear convergence in progress\n=3: Quadratic convergence in progress\n\n\n\n\n\n\nSTATS_IFAIL\n\n\nFailure code to be checked in case the return code is 80/81.\n\n\n\n\n\n\nSTATS_PRECISION\n\n\nThe sequence of acheived precisions over the iteration steps.\n\n\n\n\n\n\n\n\n\n\nStatistics stored only if OPT_STORE = 1\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSTATS_XITER\n\n\nAn array holding all iterates of the Newton iteration run\n\n\n\n\n\n\nSTATS_NATLEVEL\n\n\nThe sequence of natural levels of the Newton corrections over the iteration steps\n\n\n\n\n\n\nSTATS_SIMLEVEL\n\n\nThe sequence of natural levels of the simplified Newton corrections over the iteration steps\n\n\n\n\n\n\nSTATS_STDLEVEL\n\n\nThe sequence of standard levels over the iteration steps\n\n\n\n\n\n\nSTATS_DAMPINGFC\n\n\nThe sequence of accepted damping factors over the iteration steps.",
            "title": "Solver Statistics"
        },
        {
            "location": "/stats/#statistics",
            "text": "Name  Description      STATS_XSCAL  After return with retCode >= 0, it contains the latest internal scaling vector used. After return with retCode == -1 in onestep mode it contains a possibly adapted (as described below) user scaling vector:     If (xScal[i] <  small) xScal[i] = small  If (xScal[i] >  great) xScal[i] = great    STATS_RTOL  Finally achieved (relative) accuracy. The estimated absolute error of component i of x_out is approximately given by abs_err[i] = rTol * xScal_out[i], where (approximately) xScal_out[i] = max(abs(x_out[i]),xScal_in[i]).    STATS_CONV  The achieved relative accuracy after the latest step    STATS_SUMX  Natural level (not Normx of printouts) of the latest iterate, i.e. sum(dx.^2), where dx = scaled Newton correction.    STATS_DLEVF  Standard level (not Normf of printouts) of the latest iterate, i.e. norm(f(x),2), where f =  nonlinear problem function.    STATS_SUBCOND  Subcondition of the linear system as estimated by the linear solver (only in case of nleq2)    STATS_SENS  Sensitivity of the linear system as estimated by the linear solver (only in case of nleq2)    STATS_NITER  Number of Newton-iterations    STATS_NCORR  Number of corrector steps    STATS_NFCN  Number of fcn-evaluations    STATS_NFCNJ  Number of fcn-evaluations for Jacobian approximation    STATS_NJAC  Number of Jacobian generations or jac-calls    STATS_NREJR1  Number of rejected Newton iteration steps done with a rank-1 approximated Jacobian    STATS_NEW  Count of consecutive rank-1 updates    STATS_ICONV  Current status of of the convergence monitor (only if convergence order monitor is on see OPT_IORMON) =0: No convergence indicated yet =1: Damping factor is 1.0 =2: Superlinear convergence in progress =3: Quadratic convergence in progress    STATS_IFAIL  Failure code to be checked in case the return code is 80/81.    STATS_PRECISION  The sequence of acheived precisions over the iteration steps.",
            "title": "Statistics"
        },
        {
            "location": "/stats/#statistics-stored-only-if-opt_store-1",
            "text": "Name  Description      STATS_XITER  An array holding all iterates of the Newton iteration run    STATS_NATLEVEL  The sequence of natural levels of the Newton corrections over the iteration steps    STATS_SIMLEVEL  The sequence of natural levels of the simplified Newton corrections over the iteration steps    STATS_STDLEVEL  The sequence of standard levels over the iteration steps    STATS_DAMPINGFC  The sequence of accepted damping factors over the iteration steps.",
            "title": "Statistics stored only if OPT_STORE = 1"
        },
        {
            "location": "/returnCodes/",
            "text": "Return codes\n\n\n\n\n\n\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n1\n\n\nTermination, since jacobian matrix became singular\n\n\n\n\n\n\n2\n\n\nTermination after nItmax iterations (as indicated by the option OPT_NITMAX)\n\n\n\n\n\n\n3\n\n\nTermination, since damping factor became to small\n\n\n\n\n\n\n4\n\n\nWarning: Superlinear or quadratic convergence slowed down near the solution. Iteration has been stopped therefore with an approximation of the solution not such accurate as requested by OPT_RTOL because possibly the OPT_RTOL requirement may be too stringent (i.e. the nonlinear problem is ill-conditioned)\n\n\n\n\n\n\n5\n\n\nWarning: Iteration stopped with termination criterion (using OPT_RTOL as requested precision) satisfied but no superlinear or quadratic convergence has been indicated yet. Therefore, possibly the error estimate for the solution may not match good enough the really achieved accuracy.\n\n\n\n\n\n\n21\n\n\nNon-positive value for OPT_RTOL supplied\n\n\n\n\n\n\n22\n\n\nNegative scaling value via vector xScal supplied\n\n\n\n\n\n\n30\n\n\nOne or more fields specified in the options are invalid\n\n\n\n\n\n\n80\n\n\nError signalled by linear solver routine nFact. The reason for failure is given by the STATS_IFAIL entry in statistics. The meaning of the value is given in nFact.\n\n\n\n\n\n\n81\n\n\nError signalled by linear solver routine nSolv. The reason for failure is given by the STATS_IFAIL entry in statistics. The meaning of the value is given in nSolv.\n\n\n\n\n\n\n82\n\n\nError signalled by user function fcn\n\n\n\n\n\n\n83\n\n\nError signalled by user function provided in OPT_JACFCN",
            "title": "Solver Return codes"
        },
        {
            "location": "/returnCodes/#return-codes",
            "text": "Value  Description      1  Termination, since jacobian matrix became singular    2  Termination after nItmax iterations (as indicated by the option OPT_NITMAX)    3  Termination, since damping factor became to small    4  Warning: Superlinear or quadratic convergence slowed down near the solution. Iteration has been stopped therefore with an approximation of the solution not such accurate as requested by OPT_RTOL because possibly the OPT_RTOL requirement may be too stringent (i.e. the nonlinear problem is ill-conditioned)    5  Warning: Iteration stopped with termination criterion (using OPT_RTOL as requested precision) satisfied but no superlinear or quadratic convergence has been indicated yet. Therefore, possibly the error estimate for the solution may not match good enough the really achieved accuracy.    21  Non-positive value for OPT_RTOL supplied    22  Negative scaling value via vector xScal supplied    30  One or more fields specified in the options are invalid    80  Error signalled by linear solver routine nFact. The reason for failure is given by the STATS_IFAIL entry in statistics. The meaning of the value is given in nFact.    81  Error signalled by linear solver routine nSolv. The reason for failure is given by the STATS_IFAIL entry in statistics. The meaning of the value is given in nSolv.    82  Error signalled by user function fcn    83  Error signalled by user function provided in OPT_JACFCN",
            "title": "Return codes"
        },
        {
            "location": "/notes/",
            "text": "Note 1 :\n\n\nThe machine dependent values small, great and epMach are set as global variables over here. As delivered, this function is adapted to use constants suitable for all machines with IEEE arithmetic. If you use another type of machine, you have to change these variables suitable for your machine.\n\n\n\n\nNote 2 :\n\n\nIf NLEQ solver terminates with retCode=2 (maximum iterations) or retCode=3 (small damping factor), you may try to continue the iteration by increasing OPT_NITMAX or decreasing OPT_FCMIN and setting OPT_QSUCC to 1.\n\n\n\n\nNote 3 :\n\n\nStorage of user supplied banded Jacobiann the band matrix case, the following lines may build up the analytic Jacobian A; Here AFL denotes the quadratic matrix A in dense form, and ABD the rectangular matrix A in banded form :\n\n\nML = getOption(opt,OPT_ML,0)\nMU = getOption(opt,OPT_MU,0)\nMH = MU+1\nfor J = 1:N\n    I1 = MAX(1,J-MU)\n    I2 = MIN(N,J+ML)\n    for I = I1:I2\n        K = I-J+MH\n        ABD[K,J] = AFL[I,J]\n    end\nend\n\n\n\n\n\nThe total number of rows needed in ABD is ML+MU+1 . The MU by MU upper left triangle and the ML by ML lower right triangle are not referenced.\n\n\n\n\nNote 4 :\n\n\nThe default values of the internal parameters may be obtained from the monitor output with at least the field OPT_PRINTIOMON set to 2 and by initializing the corresponding options to zero.\n\n\n\n\nNote 5 :\n\n\nin case of failure:\n\n\n\n\nuse non-standard options\n\n\nor turn to Newton-algorithm with rank strategy\n\n\nuse another initial guess\n\n\nor reformulate model\n\n\nor apply continuation techniques",
            "title": "Important notes"
        }
    ]
}